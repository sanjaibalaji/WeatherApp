{"ast":null,"code":"import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nvar MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\r\n   * Counts the depth of list fields in \"__Type\" recursively and\r\n   * returns `true` if the limit has been reached.\r\n   */\n  function checkDepth(node) {\n    var visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      var _fragmentName = node.name.value;\n      if (visitedFragments[_fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n      var fragment = context.getFragment(_fragmentName);\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[_fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[_fragmentName] = null;\n      }\n    }\n    if (node.kind === Kind.FIELD && (\n    // check all introspection lists\n    node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {\n      // $FlowFixMe[reassign-const] why are argument parameters treated as const in flow?\n      depth++; // eslint-disable-line no-param-reassign\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (var _i2 = 0, _node$selectionSet$se2 = node.selectionSet.selections; _i2 < _node$selectionSet$se2.length; _i2++) {\n        var child = _node$selectionSet$se2[_i2];\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  return {\n    Field: function Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(new GraphQLError('Maximum introspection depth exceeded', [node]));\n          return false;\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","MAX_LISTS_DEPTH","MaxIntrospectionDepthRule","context","checkDepth","node","visitedFragments","arguments","length","undefined","Object","create","depth","kind","FRAGMENT_SPREAD","_fragmentName","name","value","fragment","getFragment","FIELD","selectionSet","_i2","_node$selectionSet$se2","selections","child","Field","reportError"],"sources":["C:/Users/Admin/Documents/weather/weather-frontend/node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\r\nimport { Kind } from \"../../language/kinds.mjs\";\r\nvar MAX_LISTS_DEPTH = 3;\r\nexport function MaxIntrospectionDepthRule(context) {\r\n  /**\r\n   * Counts the depth of list fields in \"__Type\" recursively and\r\n   * returns `true` if the limit has been reached.\r\n   */\r\n  function checkDepth(node) {\r\n    var visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\r\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n\r\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\r\n      var _fragmentName = node.name.value;\r\n\r\n      if (visitedFragments[_fragmentName] === true) {\r\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\r\n        return false;\r\n      }\r\n\r\n      var fragment = context.getFragment(_fragmentName);\r\n\r\n      if (!fragment) {\r\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\r\n        return false;\r\n      } // Rather than following an immutable programming pattern which has\r\n      // significant memory and garbage collection overhead, we've opted to\r\n      // take a mutable approach for efficiency's sake. Importantly visiting a\r\n      // fragment twice is fine, so long as you don't do one visit inside the\r\n      // other.\r\n\r\n\r\n      try {\r\n        visitedFragments[_fragmentName] = true;\r\n        return checkDepth(fragment, visitedFragments, depth);\r\n      } finally {\r\n        visitedFragments[_fragmentName] = null;\r\n      }\r\n    }\r\n\r\n    if (node.kind === Kind.FIELD && ( // check all introspection lists\r\n    node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {\r\n      // $FlowFixMe[reassign-const] why are argument parameters treated as const in flow?\r\n      depth++; // eslint-disable-line no-param-reassign\r\n\r\n      if (depth >= MAX_LISTS_DEPTH) {\r\n        return true;\r\n      }\r\n    } // handles fields and inline fragments\r\n\r\n\r\n    if ('selectionSet' in node && node.selectionSet) {\r\n      for (var _i2 = 0, _node$selectionSet$se2 = node.selectionSet.selections; _i2 < _node$selectionSet$se2.length; _i2++) {\r\n        var child = _node$selectionSet$se2[_i2];\r\n\r\n        if (checkDepth(child, visitedFragments, depth)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  return {\r\n    Field: function Field(node) {\r\n      if (node.name.value === '__schema' || node.name.value === '__type') {\r\n        if (checkDepth(node)) {\r\n          context.reportError(new GraphQLError('Maximum introspection depth exceeded', [node]));\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,IAAI,QAAQ,0BAA0B;AAC/C,IAAIC,eAAe,GAAG,CAAC;AACvB,OAAO,SAASC,yBAAyBA,CAACC,OAAO,EAAE;EACjD;AACF;AACA;AACA;EACE,SAASC,UAAUA,CAACC,IAAI,EAAE;IACxB,IAAIC,gBAAgB,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGG,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IAC9G,IAAIC,KAAK,GAAGL,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;IAEjF,IAAIF,IAAI,CAACQ,IAAI,KAAKb,IAAI,CAACc,eAAe,EAAE;MACtC,IAAIC,aAAa,GAAGV,IAAI,CAACW,IAAI,CAACC,KAAK;MAEnC,IAAIX,gBAAgB,CAACS,aAAa,CAAC,KAAK,IAAI,EAAE;QAC5C;QACA,OAAO,KAAK;MACd;MAEA,IAAIG,QAAQ,GAAGf,OAAO,CAACgB,WAAW,CAACJ,aAAa,CAAC;MAEjD,IAAI,CAACG,QAAQ,EAAE;QACb;QACA,OAAO,KAAK;MACd,CAAC,CAAC;MACF;MACA;MACA;MACA;;MAGA,IAAI;QACFZ,gBAAgB,CAACS,aAAa,CAAC,GAAG,IAAI;QACtC,OAAOX,UAAU,CAACc,QAAQ,EAAEZ,gBAAgB,EAAEM,KAAK,CAAC;MACtD,CAAC,SAAS;QACRN,gBAAgB,CAACS,aAAa,CAAC,GAAG,IAAI;MACxC;IACF;IAEA,IAAIV,IAAI,CAACQ,IAAI,KAAKb,IAAI,CAACoB,KAAK;IAAM;IAClCf,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,QAAQ,IAAIZ,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,YAAY,IAAIZ,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,eAAe,IAAIZ,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,aAAa,CAAC,EAAE;MAC7I;MACAL,KAAK,EAAE,CAAC,CAAC;;MAET,IAAIA,KAAK,IAAIX,eAAe,EAAE;QAC5B,OAAO,IAAI;MACb;IACF,CAAC,CAAC;;IAGF,IAAI,cAAc,IAAII,IAAI,IAAIA,IAAI,CAACgB,YAAY,EAAE;MAC/C,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEC,sBAAsB,GAAGlB,IAAI,CAACgB,YAAY,CAACG,UAAU,EAAEF,GAAG,GAAGC,sBAAsB,CAACf,MAAM,EAAEc,GAAG,EAAE,EAAE;QACnH,IAAIG,KAAK,GAAGF,sBAAsB,CAACD,GAAG,CAAC;QAEvC,IAAIlB,UAAU,CAACqB,KAAK,EAAEnB,gBAAgB,EAAEM,KAAK,CAAC,EAAE;UAC9C,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEA,OAAO;IACLc,KAAK,EAAE,SAASA,KAAKA,CAACrB,IAAI,EAAE;MAC1B,IAAIA,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,UAAU,IAAIZ,IAAI,CAACW,IAAI,CAACC,KAAK,KAAK,QAAQ,EAAE;QAClE,IAAIb,UAAU,CAACC,IAAI,CAAC,EAAE;UACpBF,OAAO,CAACwB,WAAW,CAAC,IAAI5B,YAAY,CAAC,sCAAsC,EAAE,CAACM,IAAI,CAAC,CAAC,CAAC;UACrF,OAAO,KAAK;QACd;MACF;IACF;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}