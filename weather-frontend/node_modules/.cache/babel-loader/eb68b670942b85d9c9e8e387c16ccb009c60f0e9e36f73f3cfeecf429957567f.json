{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// src/useQuery.ts\nimport { ref as ref3, unref, computed as computed3, watch as watch2, onServerPrefetch, getCurrentScope as getCurrentScope2, getCurrentInstance, onScopeDispose as onScopeDispose2, nextTick, shallowRef } from \"vue-demi\";\nimport { throttle, debounce } from \"throttle-debounce\";\n\n// src/useApolloClient.ts\nimport { hasInjectionContext, inject } from \"vue-demi\";\nvar DefaultApolloClient = Symbol(\"default-apollo-client\");\nvar ApolloClients = Symbol(\"apollo-clients\");\nfunction resolveDefaultClient(providedApolloClients, providedApolloClient) {\n  const resolvedClient = providedApolloClients ? providedApolloClients.default : providedApolloClient != null ? providedApolloClient : void 0;\n  return resolvedClient;\n}\nfunction resolveClientWithId(providedApolloClients, clientId) {\n  return providedApolloClients == null ? void 0 : providedApolloClients[clientId];\n}\nfunction useApolloClient(clientId) {\n  let resolveImpl;\n  const savedCurrentClients = currentApolloClients;\n  if (!hasInjectionContext()) {\n    resolveImpl = id => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  } else {\n    const providedApolloClients = inject(ApolloClients, null);\n    const providedApolloClient = inject(DefaultApolloClient, null);\n    resolveImpl = id => {\n      if (id) {\n        const client2 = resolveClientWithId(providedApolloClients, id);\n        if (client2) {\n          return client2;\n        }\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient);\n      if (client) {\n        return client;\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  }\n  function resolveClient(id = clientId) {\n    const client = resolveImpl(id);\n    if (!client) {\n      throw new Error(`Apollo client with id ${id != null ? id : \"default\"} not found. Use an app.runWithContext() or provideApolloClient() if you are outside of a component setup.`);\n    }\n    return client;\n  }\n  return {\n    resolveClient,\n    get client() {\n      return resolveClient();\n    }\n  };\n}\nvar currentApolloClients = {};\nfunction provideApolloClient(client) {\n  currentApolloClients = {\n    default: client\n  };\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\nfunction provideApolloClients(clients) {\n  currentApolloClients = clients;\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\n\n// src/util/paramToRef.ts\nimport { isRef, computed, ref } from \"vue-demi\";\nfunction paramToRef(param) {\n  if (isRef(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed(param);\n  } else {\n    return ref(param);\n  }\n}\n\n// src/util/paramToReactive.ts\nimport { isRef as isRef2, reactive, computed as computed2 } from \"vue-demi\";\nfunction paramToReactive(param) {\n  if (isRef2(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed2(param);\n  } else if (param) {\n    return reactive(param);\n  } else {\n    return param;\n  }\n}\n\n// src/util/useEventHook.ts\nfunction useEventHook() {\n  const fns = [];\n  function on(fn) {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  }\n  function off(fn) {\n    const index = fns.indexOf(fn);\n    if (index !== -1) {\n      fns.splice(index, 1);\n    }\n  }\n  function trigger(...params) {\n    for (const fn of fns) {\n      fn(...params);\n    }\n  }\n  function getCount() {\n    return fns.length;\n  }\n  return {\n    on,\n    off,\n    trigger,\n    getCount\n  };\n}\n\n// src/util/loadingTracking.ts\nimport { watch, ref as ref2, getCurrentScope, onScopeDispose } from \"vue-demi\";\n\n// src/util/env.ts\nvar isServer = typeof window === \"undefined\";\n\n// src/util/loadingTracking.ts\nvar globalTracking = {\n  queries: ref2(0),\n  mutations: ref2(0),\n  subscriptions: ref2(0),\n  components: new Map()\n};\nfunction getCurrentTracking() {\n  const currentScope = getCurrentScope();\n  if (!currentScope) {\n    return {};\n  }\n  let tracking;\n  if (!globalTracking.components.has(currentScope)) {\n    globalTracking.components.set(currentScope, tracking = {\n      queries: ref2(0),\n      mutations: ref2(0),\n      subscriptions: ref2(0)\n    });\n    onScopeDispose(() => {\n      globalTracking.components.delete(currentScope);\n    });\n  } else {\n    tracking = globalTracking.components.get(currentScope);\n  }\n  return {\n    tracking\n  };\n}\nfunction track(loading, type) {\n  if (isServer) return;\n  const {\n    tracking\n  } = getCurrentTracking();\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1;\n      if (tracking) tracking[type].value += mod;\n      globalTracking[type].value += mod;\n    }\n  }, {\n    immediate: true\n  });\n  onScopeDispose(() => {\n    if (loading.value) {\n      if (tracking) tracking[type].value--;\n      globalTracking[type].value--;\n    }\n  });\n}\nfunction trackQuery(loading) {\n  track(loading, \"queries\");\n}\nfunction trackMutation(loading) {\n  track(loading, \"mutations\");\n}\nfunction trackSubscription(loading) {\n  track(loading, \"subscriptions\");\n}\n\n// src/util/toApolloError.ts\nimport { ApolloError, isApolloError } from \"@apollo/client/core/index.js\";\nfunction toApolloError(error) {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), {\n        originalError: error\n      }),\n      errorMessage: String(error)\n    });\n  }\n  if (isApolloError(error)) {\n    return error;\n  }\n  return new ApolloError({\n    networkError: error,\n    errorMessage: error.message\n  });\n}\nfunction resultErrorsToApolloError(errors) {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map(e => e.message).join(\" | \")}`\n  });\n}\n\n// src/useQuery.ts\nfunction useQuery(document, variables, options) {\n  return useQueryImpl(document, variables, options);\n}\nfunction useQueryImpl(document, variables, options = {}, lazy = false) {\n  var _a;\n  const currentScope = getCurrentScope2();\n  const currentInstance = getCurrentInstance();\n  const currentOptions = ref3();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = shallowRef();\n  const resultEvent = useEventHook();\n  const error = shallowRef(null);\n  const errorEvent = useEventHook();\n  const loading = ref3(false);\n  currentScope && trackQuery(loading);\n  const networkStatus = ref3();\n  let firstResolve;\n  let firstResolveTriggered = false;\n  let firstReject;\n  let firstRejectError;\n  const tryFirstResolve = () => {\n    firstResolveTriggered = true;\n    if (firstResolve) firstResolve();\n  };\n  const tryFirstReject = apolloError => {\n    firstRejectError = apolloError;\n    if (firstReject) firstReject(apolloError);\n  };\n  const resetFirstResolveReject = () => {\n    firstResolve = void 0;\n    firstReject = void 0;\n    firstResolveTriggered = false;\n    firstRejectError = void 0;\n  };\n  currentInstance && ((_a = onServerPrefetch) == null ? void 0 : _a(() => {\n    var _a2;\n    if (!isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false) return;\n    return new Promise((resolve, reject) => {\n      firstResolve = () => {\n        resetFirstResolveReject();\n        resolve();\n      };\n      firstReject = apolloError => {\n        resetFirstResolveReject();\n        reject(apolloError);\n      };\n      if (firstResolveTriggered) {\n        firstResolve();\n      } else if (firstRejectError) {\n        firstReject(firstRejectError);\n      }\n    }).finally(stop);\n  }));\n  const {\n    resolveClient\n  } = useApolloClient();\n  function getClient() {\n    var _a2;\n    return resolveClient((_a2 = currentOptions.value) == null ? void 0 : _a2.clientId);\n  }\n  const query = shallowRef();\n  let observer;\n  let started = false;\n  let ignoreNextResult = false;\n  let firstStart = true;\n  function start() {\n    var _a2, _b, _c, _d, _e;\n    if (started || !isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false || !currentDocument) {\n      tryFirstResolve();\n      return;\n    }\n    if (isServer) {\n      applyDocument(documentRef.value);\n      applyVariables(variablesRef.value);\n      applyOptions(unref(optionsRef));\n    }\n    started = true;\n    error.value = null;\n    loading.value = true;\n    const client = getClient();\n    query.value = client.watchQuery({\n      query: currentDocument,\n      variables: currentVariables != null ? currentVariables : {},\n      ...currentOptions.value,\n      ...(isServer && ((_b = currentOptions.value) == null ? void 0 : _b.fetchPolicy) !== \"no-cache\" ? {\n        fetchPolicy: \"network-only\"\n      } : {})\n    });\n    startQuerySubscription();\n    if (!isServer && (firstStart || !((_c = currentOptions.value) == null ? void 0 : _c.keepPreviousResult)) && (((_d = currentOptions.value) == null ? void 0 : _d.fetchPolicy) !== \"no-cache\" || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false);\n      if (!currentResult.loading || currentResult.partial || ((_e = currentOptions.value) == null ? void 0 : _e.notifyOnNetworkStatusChange)) {\n        onNextResult(currentResult);\n        ignoreNextResult = !currentResult.loading;\n      } else if (currentResult.error) {\n        onError(currentResult.error);\n        ignoreNextResult = true;\n      }\n    }\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item);\n      }\n    }\n    firstStart = false;\n  }\n  function startQuerySubscription() {\n    if (observer && !observer.closed) return;\n    if (!query.value) return;\n    ignoreNextResult = false;\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function getErrorPolicy() {\n    var _a2, _b, _c, _d;\n    const client = resolveClient((_a2 = currentOptions.value) == null ? void 0 : _a2.clientId);\n    return ((_b = currentOptions.value) == null ? void 0 : _b.errorPolicy) || ((_d = (_c = client.defaultOptions) == null ? void 0 : _c.watchQuery) == null ? void 0 : _d.errorPolicy);\n  }\n  function onNextResult(queryResult) {\n    var _a2;\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    error.value = null;\n    processNextResult(queryResult);\n    const errorPolicy = getErrorPolicy();\n    if (errorPolicy && errorPolicy === \"all\" && !queryResult.error && ((_a2 = queryResult.errors) == null ? void 0 : _a2.length)) {\n      processError(resultErrorsToApolloError(queryResult.errors));\n    }\n    tryFirstResolve();\n  }\n  function processNextResult(queryResult) {\n    var _a2, _b;\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? queryResult.error && !((_a2 = currentOptions.value) == null ? void 0 : _a2.returnPartialData) && ((_b = currentOptions.value) == null ? void 0 : _b.errorPolicy) === \"none\" ? void 0 : result.value : queryResult.data;\n    loading.value = queryResult.loading;\n    networkStatus.value = queryResult.networkStatus;\n    nextTick(() => {\n      resultEvent.trigger(queryResult, {\n        client: getClient()\n      });\n    });\n  }\n  function onError(queryError) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    const apolloError = toApolloError(queryError);\n    const errorPolicy = getErrorPolicy();\n    if (errorPolicy && errorPolicy !== \"none\") {\n      processNextResult(query.value.getCurrentResult());\n    }\n    processError(apolloError);\n    tryFirstReject(apolloError);\n    resubscribeToQuery();\n  }\n  function processError(apolloError) {\n    error.value = apolloError;\n    loading.value = false;\n    networkStatus.value = 8;\n    nextTick(() => {\n      errorEvent.trigger(apolloError, {\n        client: getClient()\n      });\n    });\n  }\n  function resubscribeToQuery() {\n    if (!query.value) return;\n    const lastError = query.value.getLastError();\n    const lastResult = query.value.getLastResult();\n    query.value.resetLastResults();\n    startQuerySubscription();\n    Object.assign(query.value, {\n      lastError,\n      lastResult\n    });\n  }\n  let onStopHandlers = [];\n  function stop() {\n    tryFirstResolve();\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    onStopHandlers.forEach(handler => handler());\n    onStopHandlers = [];\n    if (query.value) {\n      query.value.stopPolling();\n      query.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = void 0;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  let isRestartDebounceSetup = false;\n  function updateRestartFn() {\n    var _a2, _b;\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart;\n    } else {\n      if ((_a2 = currentOptions.value) == null ? void 0 : _a2.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart);\n      } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart);\n      } else {\n        debouncedRestart = baseRestart;\n      }\n      isRestartDebounceSetup = true;\n    }\n  }\n  function restart() {\n    if (!started || restarting) return;\n    if (!isRestartDebounceSetup) updateRestartFn();\n    debouncedRestart();\n  }\n  let currentDocument = documentRef.value;\n  const forceDisabled = ref3(lazy);\n  const enabledOption = computed3(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = computed3(() => enabledOption.value && !forceDisabled.value && !!documentRef.value);\n  watch2(() => unref(optionsRef), applyOptions, {\n    deep: true,\n    immediate: true\n  });\n  function applyOptions(value) {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }\n  watch2(documentRef, applyDocument);\n  function applyDocument(value) {\n    currentDocument = value;\n    restart();\n  }\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch2(() => {\n    if (isEnabled.value) {\n      return variablesRef.value;\n    } else {\n      return void 0;\n    }\n  }, applyVariables, {\n    deep: true,\n    immediate: true\n  });\n  function applyVariables(value) {\n    const serialized = JSON.stringify([value, isEnabled.value]);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }\n  function refetch(variables2 = void 0) {\n    if (query.value) {\n      if (variables2) {\n        currentVariables = variables2;\n      }\n      error.value = null;\n      loading.value = true;\n      return query.value.refetch(variables2).then(refetchResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return refetchResult;\n      });\n    }\n  }\n  function updateQuery(mapFn) {\n    if (query.value) {\n      query.value.updateQuery(mapFn);\n    }\n  }\n  function fetchMore(options2) {\n    if (query.value) {\n      error.value = null;\n      loading.value = true;\n      return query.value.fetchMore(options2).then(fetchMoreResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return fetchMoreResult;\n      });\n    }\n  }\n  const subscribeToMoreItems = [];\n  function subscribeToMore(options2) {\n    if (isServer) return;\n    const optionsRef2 = paramToRef(options2);\n    watch2(optionsRef2, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item2 => item2.options === oldValue);\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1);\n      }\n      const item = {\n        options: value,\n        unsubscribeFns: []\n      };\n      subscribeToMoreItems.push(item);\n      addSubscribeToMore(item);\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn());\n        item.unsubscribeFns = [];\n      });\n    }, {\n      immediate: true\n    });\n  }\n  function addSubscribeToMore(item) {\n    if (!started) return;\n    if (!query.value) {\n      throw new Error(\"Query is not defined\");\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options);\n    onStopHandlers.push(unsubscribe);\n    item.unsubscribeFns.push(unsubscribe);\n  }\n  watch2(isEnabled, value => {\n    if (value) {\n      nextTick(() => {\n        start();\n      });\n    } else {\n      stop();\n    }\n  });\n  if (isEnabled.value) {\n    start();\n  }\n  if (currentScope) {\n    onScopeDispose2(() => {\n      stop();\n      subscribeToMoreItems.length = 0;\n    });\n  } else {\n    console.warn(\"[Vue apollo] useQuery() is called outside of an active effect scope and the query will not be automatically stopped.\");\n  }\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    updateQuery,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useLazyQuery.ts\nimport { isRef as isRef3 } from \"vue-demi\";\nfunction useLazyQuery(document, variables, options) {\n  const query = useQueryImpl(document, variables, options, true);\n  function load(document2, variables2, options2) {\n    if (document2) {\n      query.document.value = document2;\n    }\n    if (variables2) {\n      query.variables.value = variables2;\n    }\n    if (options2) {\n      Object.assign(isRef3(query.options) ? query.options.value : query.options, options2);\n    }\n    const isFirstRun = query.forceDisabled.value;\n    if (isFirstRun) {\n      query.forceDisabled.value = false;\n      if (isServer) {\n        query.start();\n      }\n      return new Promise((resolve, reject) => {\n        const {\n          off: offResult\n        } = query.onResult(result => {\n          if (!result.loading) {\n            resolve(result.data);\n            offResult();\n            offError();\n          }\n        });\n        const {\n          off: offError\n        } = query.onError(error => {\n          reject(error);\n          offResult();\n          offError();\n        });\n      });\n    } else {\n      return false;\n    }\n  }\n  return {\n    ...query,\n    load\n  };\n}\n\n// src/useMutation.ts\nimport { ref as ref4, onScopeDispose as onScopeDispose3, isRef as isRef4, getCurrentScope as getCurrentScope3, shallowRef as shallowRef2, nextTick as nextTick2 } from \"vue-demi\";\nfunction useMutation(document, options = {}) {\n  const currentScope = getCurrentScope3();\n  const loading = ref4(false);\n  currentScope && trackMutation(loading);\n  const error = shallowRef2(null);\n  const called = ref4(false);\n  const doneEvent = useEventHook();\n  const errorEvent = useEventHook();\n  const {\n    resolveClient\n  } = useApolloClient();\n  async function mutate(variables, overrideOptions = {}) {\n    let currentDocument;\n    if (typeof document === \"function\") {\n      currentDocument = document();\n    } else if (isRef4(document)) {\n      currentDocument = document.value;\n    } else {\n      currentDocument = document;\n    }\n    let currentOptions;\n    if (typeof options === \"function\") {\n      currentOptions = options();\n    } else if (isRef4(options)) {\n      currentOptions = options.value;\n    } else {\n      currentOptions = options;\n    }\n    const client = resolveClient(currentOptions.clientId);\n    error.value = null;\n    loading.value = true;\n    called.value = true;\n    try {\n      const result = await client.mutate({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables != null ? variables : currentOptions.variables) ? {\n          ...currentOptions.variables,\n          ...variables\n        } : void 0\n      });\n      loading.value = false;\n      await nextTick2();\n      doneEvent.trigger(result, {\n        client\n      });\n      return result;\n    } catch (e) {\n      const apolloError = toApolloError(e);\n      error.value = apolloError;\n      loading.value = false;\n      errorEvent.trigger(apolloError, {\n        client\n      });\n      if (currentOptions.throws === \"always\" || currentOptions.throws !== \"never\" && !errorEvent.getCount()) {\n        throw apolloError;\n      }\n    }\n    return null;\n  }\n  currentScope && onScopeDispose3(() => {\n    loading.value = false;\n  });\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useSubscription.ts\nimport { ref as ref5, watch as watch3, isRef as isRef5, computed as computed4, getCurrentScope as getCurrentScope4, onScopeDispose as onScopeDispose4, nextTick as nextTick3, shallowRef as shallowRef3 } from \"vue-demi\";\nimport { throttle as throttle2, debounce as debounce2 } from \"throttle-debounce\";\nfunction useSubscription(document, variables = void 0, options = {}) {\n  const currentScope = getCurrentScope4();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = shallowRef3();\n  const resultEvent = useEventHook();\n  const error = shallowRef3(null);\n  const errorEvent = useEventHook();\n  const loading = ref5(false);\n  currentScope && trackSubscription(loading);\n  const {\n    resolveClient\n  } = useApolloClient();\n  const subscription = ref5(null);\n  let observer = null;\n  let started = false;\n  function getClient() {\n    var _a;\n    return resolveClient((_a = currentOptions.value) == null ? void 0 : _a.clientId);\n  }\n  function start() {\n    if (started || !isEnabled.value || isServer) return;\n    started = true;\n    loading.value = true;\n    const client = getClient();\n    subscription.value = client.subscribe({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value\n    });\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function onNextResult(fetchResult) {\n    result.value = fetchResult.data;\n    loading.value = false;\n    resultEvent.trigger(fetchResult, {\n      client: getClient()\n    });\n  }\n  function onError(fetchError) {\n    const apolloError = toApolloError(fetchError);\n    error.value = apolloError;\n    loading.value = false;\n    errorEvent.trigger(apolloError, {\n      client: getClient()\n    });\n  }\n  function stop() {\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    if (subscription.value) {\n      subscription.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = null;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick3(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  function updateRestartFn() {\n    var _a, _b;\n    if ((_a = currentOptions.value) == null ? void 0 : _a.throttle) {\n      debouncedRestart = throttle2(currentOptions.value.throttle, baseRestart);\n    } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n      debouncedRestart = debounce2(currentOptions.value.debounce, baseRestart);\n    } else {\n      debouncedRestart = baseRestart;\n    }\n  }\n  function restart() {\n    if (!debouncedRestart) updateRestartFn();\n    debouncedRestart();\n  }\n  const currentOptions = ref5();\n  watch3(() => isRef5(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }, {\n    deep: true,\n    immediate: true\n  });\n  let currentDocument;\n  watch3(documentRef, value => {\n    currentDocument = value;\n    restart();\n  }, {\n    immediate: true\n  });\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch3(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }, {\n    deep: true,\n    immediate: true\n  });\n  const enabledOption = computed4(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = enabledOption;\n  watch3(isEnabled, value => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  }, {\n    immediate: true\n  });\n  if (currentScope) {\n    onScopeDispose4(stop);\n  } else {\n    console.warn(\"[Vue apollo] useSubscription() is called outside of an active effect scope and the subscription will not be automatically stopped.\");\n  }\n  return {\n    result,\n    loading,\n    error,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useResult.ts\nimport { computed as computed5 } from \"vue-demi\";\nfunction useResult(result, defaultValue, pick) {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`);\n  return computed5(() => {\n    const value = result.value;\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value);\n        } catch (e) {}\n      } else {\n        const keys = Object.keys(value);\n        if (keys.length === 1) {\n          return value[keys[0]];\n        } else {\n          return value;\n        }\n      }\n    }\n    return defaultValue;\n  });\n}\n\n// src/useLoading.ts\nimport { computed as computed6 } from \"vue-demi\";\nfunction useQueryLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useQueryLoading must be called inside a setup function.\");\n  return computed6(() => tracking.queries.value > 0);\n}\nfunction useMutationLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useMutationLoading must be called inside a setup function.\");\n  return computed6(() => tracking.mutations.value > 0);\n}\nfunction useSubscriptionLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useSubscriptionLoading must be called inside a setup function.\");\n  return computed6(() => tracking.subscriptions.value > 0);\n}\nfunction useGlobalQueryLoading() {\n  return computed6(() => globalTracking.queries.value > 0);\n}\nfunction useGlobalMutationLoading() {\n  return computed6(() => globalTracking.mutations.value > 0);\n}\nfunction useGlobalSubscriptionLoading() {\n  return computed6(() => globalTracking.subscriptions.value > 0);\n}\nexport { ApolloClients, DefaultApolloClient, provideApolloClient, provideApolloClients, useApolloClient, useGlobalMutationLoading, useGlobalQueryLoading, useGlobalSubscriptionLoading, useLazyQuery, useMutation, useMutationLoading, useQuery, useQueryLoading, useResult, useSubscription, useSubscriptionLoading };","map":{"version":3,"names":["ref","ref3","unref","computed","computed3","watch","watch2","onServerPrefetch","getCurrentScope","getCurrentScope2","getCurrentInstance","onScopeDispose","onScopeDispose2","nextTick","shallowRef","throttle","debounce","hasInjectionContext","inject","DefaultApolloClient","Symbol","ApolloClients","resolveDefaultClient","providedApolloClients","providedApolloClient","resolvedClient","default","resolveClientWithId","clientId","useApolloClient","resolveImpl","savedCurrentClients","currentApolloClients","id","client2","client","resolveClient","Error","provideApolloClient","fn","result","provideApolloClients","clients","isRef","paramToRef","param","isRef2","reactive","computed2","paramToReactive","useEventHook","fns","on","push","off","index","indexOf","splice","trigger","params","getCount","length","ref2","isServer","window","globalTracking","queries","mutations","subscriptions","components","Map","getCurrentTracking","currentScope","tracking","has","set","delete","get","track","loading","type","value","oldValue","mod","immediate","trackQuery","trackMutation","trackSubscription","ApolloError","isApolloError","toApolloError","error","networkError","Object","assign","originalError","errorMessage","String","message","resultErrorsToApolloError","errors","graphQLErrors","map","e","join","useQuery","document","variables","options","useQueryImpl","lazy","_a","currentInstance","currentOptions","documentRef","variablesRef","optionsRef","resultEvent","errorEvent","networkStatus","firstResolve","firstResolveTriggered","firstReject","firstRejectError","tryFirstResolve","tryFirstReject","apolloError","resetFirstResolveReject","_a2","isEnabled","prefetch","Promise","resolve","reject","finally","stop","getClient","query","observer","started","ignoreNextResult","firstStart","start","_b","_c","_d","_e","currentDocument","applyDocument","applyVariables","applyOptions","watchQuery","currentVariables","fetchPolicy","startQuerySubscription","keepPreviousResult","notifyOnNetworkStatusChange","currentResult","getCurrentResult","partial","onNextResult","onError","item","subscribeToMoreItems","addSubscribeToMore","closed","subscribe","next","getErrorPolicy","errorPolicy","defaultOptions","queryResult","processNextResult","processError","data","keys","returnPartialData","queryError","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","onStopHandlers","forEach","handler","stopPolling","unsubscribe","restarting","baseRestart","debouncedRestart","isRestartDebounceSetup","updateRestartFn","restart","forceDisabled","enabledOption","enabled","deep","currentVariablesSerialized","serialized","JSON","stringify","refetch","variables2","then","refetchResult","updateQuery","mapFn","fetchMore","options2","fetchMoreResult","subscribeToMore","optionsRef2","onCleanup","findIndex","item2","unsubscribeFns","console","warn","onResult","isRef3","useLazyQuery","load","document2","isFirstRun","offResult","offError","ref4","onScopeDispose3","isRef4","getCurrentScope3","shallowRef2","nextTick2","useMutation","called","doneEvent","mutate","overrideOptions","mutation","throws","onDone","ref5","watch3","isRef5","computed4","getCurrentScope4","onScopeDispose4","nextTick3","shallowRef3","throttle2","debounce2","useSubscription","subscription","fetchResult","fetchError","computed5","useResult","defaultValue","pick","computed6","useQueryLoading","useMutationLoading","useSubscriptionLoading","useGlobalQueryLoading","useGlobalMutationLoading","useGlobalSubscriptionLoading"],"sources":["../src/useQuery.ts","../src/useApolloClient.ts","../src/util/paramToRef.ts","../src/util/paramToReactive.ts","../src/util/useEventHook.ts","../src/util/loadingTracking.ts","../src/util/env.ts","../src/util/toApolloError.ts","../src/useLazyQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useResult.ts","../src/useLoading.ts"],"sourcesContent":["import {\n  ref,\n  Ref,\n  unref,\n  computed,\n  watch,\n  onServerPrefetch,\n  getCurrentScope,\n  getCurrentInstance,\n  onScopeDispose,\n  nextTick,\n  shallowRef,\n} from 'vue-demi'\nimport { DocumentNode } from 'graphql'\nimport type {\n  OperationVariables,\n  WatchQueryOptions,\n  ObservableQuery,\n  ApolloQueryResult,\n  SubscribeToMoreOptions,\n  FetchMoreQueryOptions,\n  FetchMoreOptions,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n  ApolloClient,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useEventHook } from './util/useEventHook'\nimport { trackQuery } from './util/loadingTracking'\nimport { resultErrorsToApolloError, toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nexport interface UseQueryOptions<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> extends Omit<WatchQueryOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean | Ref<boolean>\n  throttle?: number\n  debounce?: number\n  prefetch?: boolean\n  keepPreviousResult?: boolean\n}\n\ninterface SubscribeToMoreItem {\n  options: any\n  unsubscribeFns: (() => void)[]\n}\n\n// Parameters\nexport type DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode | null | undefined> | ReactiveFunction<DocumentNode | null | undefined> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables> | null | undefined> | ReactiveFunction<TypedDocumentNode<TResult, TVariables> | null | undefined>\nexport type VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\nexport type OptionsParameter<TResult, TVariables extends OperationVariables> = UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>> | ReactiveFunction<UseQueryOptions<TResult, TVariables>>\n\nexport interface OnResultContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\n// Return\nexport interface UseQueryReturn<TResult, TVariables extends OperationVariables> {\n  result: Ref<TResult | undefined>\n  loading: Ref<boolean>\n  networkStatus: Ref<number | undefined>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  forceDisabled: Ref<boolean>\n  document: Ref<DocumentNode | null | undefined>\n  variables: Ref<TVariables | undefined>\n  options: UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>>\n  query: Ref<ObservableQuery<TResult, TVariables> | null | undefined>\n  refetch: (variables?: TVariables) => Promise<ApolloQueryResult<TResult>> | undefined\n  fetchMore: (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) => Promise<ApolloQueryResult<TResult>> | undefined\n  updateQuery: (mapFn: (previousQueryResult: TResult, options: Pick<WatchQueryOptions<TVariables, TResult>, 'variables'>) => TResult) => void\n  subscribeToMore: <TSubscriptionVariables = OperationVariables, TSubscriptionData = TResult>(options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> | Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> | ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>) => void\n  onResult: (fn: (param: ApolloQueryResult<TResult>, context: OnResultContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a query that does not require variables or options.\n * */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseQueryReturn<TResult, Record<string, never>>\n\n/**\n * Use a query that has optional variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that has required variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that requires options but not variables.\n */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, Record<string, never>>,\n): UseQueryReturn<TResult, Record<string, never>>\n\n/**\n * Use a query that requires variables and options.\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables>\n\nexport function useQuery<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables> {\n  return useQueryImpl<TResult, TVariables>(document, variables, options)\n}\n\nexport function useQueryImpl<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n  lazy = false,\n): UseQueryReturn<TResult, TVariables> {\n  const currentScope = getCurrentScope()\n  const currentInstance = getCurrentInstance()\n\n  const currentOptions = ref<UseQueryOptions<TResult, TVariables>>()\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  // Result\n  /**\n   * Result from the query\n   */\n  const result = shallowRef<TResult | undefined>()\n  const resultEvent = useEventHook<[ApolloQueryResult<TResult>, OnResultContext]>()\n  const error = shallowRef<ApolloError | null>(null)\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  // Loading\n\n  /**\n   * Indicates if a network request is pending\n   */\n  const loading = ref(false)\n  currentScope && trackQuery(loading)\n  const networkStatus = ref<number>()\n\n  // SSR\n  let firstResolve: (() => void) | undefined\n  let firstResolveTriggered = false\n  let firstReject: ((apolloError: ApolloError) => void) | undefined\n  let firstRejectError: undefined | ApolloError\n\n  const tryFirstResolve = () => {\n    firstResolveTriggered = true\n    if (firstResolve) firstResolve()\n  }\n\n  const tryFirstReject = (apolloError: ApolloError) => {\n    firstRejectError = apolloError\n    if (firstReject) firstReject(apolloError)\n  }\n\n  const resetFirstResolveReject = () => {\n    firstResolve = undefined\n    firstReject = undefined\n    firstResolveTriggered = false\n    firstRejectError = undefined\n  }\n\n  currentInstance && onServerPrefetch?.(() => {\n    if (!isEnabled.value || (isServer && currentOptions.value?.prefetch === false)) return\n\n    return new Promise<void>((resolve, reject) => {\n      firstResolve = () => {\n        resetFirstResolveReject()\n        resolve()\n      }\n      firstReject = (apolloError: ApolloError) => {\n        resetFirstResolveReject()\n        reject(apolloError)\n      }\n\n      if (firstResolveTriggered) {\n        firstResolve()\n      } else if (firstRejectError) {\n        firstReject(firstRejectError)\n      }\n    }).finally(stop)\n  })\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  function getClient () {\n    return resolveClient(currentOptions.value?.clientId)\n  }\n\n  // Query\n\n  const query: Ref<ObservableQuery<TResult, TVariables> | null | undefined> = shallowRef()\n  let observer: ObservableSubscription | undefined\n  let started = false\n  let ignoreNextResult = false\n  let firstStart = true\n\n  /**\n   * Starts watching the query\n   */\n  function start () {\n    if (\n      started || !isEnabled.value ||\n      (isServer && currentOptions.value?.prefetch === false) ||\n      !currentDocument\n    ) {\n      tryFirstResolve()\n      return\n    }\n\n    // On server the watchers on document, variables and options are not triggered\n    if (isServer) {\n      applyDocument(documentRef.value)\n      applyVariables(variablesRef.value)\n      applyOptions(unref(optionsRef))\n    }\n\n    started = true\n    error.value = null\n    loading.value = true\n\n    const client = getClient()\n\n    query.value = client.watchQuery<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables ?? {} as TVariables,\n      ...currentOptions.value,\n      ...(isServer && currentOptions.value?.fetchPolicy !== 'no-cache')\n        ? {\n          fetchPolicy: 'network-only',\n        }\n        : {},\n    })\n\n    startQuerySubscription()\n\n    // Make the cache data available to the component immediately\n    // This prevents SSR hydration mismatches\n    if (!isServer && (firstStart || !currentOptions.value?.keepPreviousResult) && (currentOptions.value?.fetchPolicy !== 'no-cache' || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false)\n\n      if (!currentResult.loading || currentResult.partial || currentOptions.value?.notifyOnNetworkStatusChange) {\n        onNextResult(currentResult)\n        ignoreNextResult = !currentResult.loading\n      } else if (currentResult.error) {\n        onError(currentResult.error)\n        ignoreNextResult = true\n      }\n    }\n\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item)\n      }\n    }\n\n    firstStart = false\n  }\n\n  function startQuerySubscription () {\n    if (observer && !observer.closed) return\n    if (!query.value) return\n\n    // Create subscription\n    ignoreNextResult = false\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function getErrorPolicy () {\n    const client = resolveClient(currentOptions.value?.clientId)\n    return currentOptions.value?.errorPolicy || client.defaultOptions?.watchQuery?.errorPolicy\n  }\n\n  function onNextResult (queryResult: ApolloQueryResult<TResult>) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // Remove any previous error that may still be present from the last fetch (so result handlers\n    // don't receive old errors that may not even be applicable anymore).\n    error.value = null\n\n    processNextResult(queryResult)\n\n    // When `errorPolicy` is `all`, `onError` will not get called and\n    // ApolloQueryResult.errors may be set at the same time as we get a result.\n    // The code is only relevant when `errorPolicy` is `all`, because for other situations it\n    // could hapen that next and error are called at the same time and then it will lead to multiple\n    // onError calls.\n    const errorPolicy = getErrorPolicy()\n    if (errorPolicy && errorPolicy === 'all' && !queryResult.error && queryResult.errors?.length) {\n      processError(resultErrorsToApolloError(queryResult.errors))\n    }\n\n    tryFirstResolve()\n  }\n\n  function processNextResult (queryResult: ApolloQueryResult<TResult>) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0\n      ? queryResult.error &&\n        !currentOptions.value?.returnPartialData &&\n        currentOptions.value?.errorPolicy === 'none'\n        ? undefined\n        : result.value\n      : queryResult.data\n    loading.value = queryResult.loading\n    networkStatus.value = queryResult.networkStatus\n    // Wait for handlers to be registered\n    nextTick(() => {\n      resultEvent.trigger(queryResult, {\n        client: getClient(),\n      })\n    })\n  }\n\n  function onError (queryError: unknown) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // any error should already be an ApolloError, but we make sure\n    const apolloError = toApolloError(queryError)\n    const errorPolicy = getErrorPolicy()\n\n    if (errorPolicy && errorPolicy !== 'none') {\n      processNextResult((query.value as ObservableQuery<TResult, TVariables>).getCurrentResult())\n    }\n    processError(apolloError)\n    tryFirstReject(apolloError)\n    // The observable closes the sub if an error occurs\n    resubscribeToQuery()\n  }\n\n  function processError (apolloError: ApolloError) {\n    error.value = apolloError\n    loading.value = false\n    networkStatus.value = 8\n    // Wait for handlers to be registered\n    nextTick(() => {\n      errorEvent.trigger(apolloError, {\n        client: getClient(),\n      })\n    })\n  }\n\n  function resubscribeToQuery () {\n    if (!query.value) return\n    const lastError = query.value.getLastError()\n    const lastResult = query.value.getLastResult()\n    query.value.resetLastResults()\n    startQuerySubscription()\n    Object.assign(query.value, { lastError, lastResult })\n  }\n\n  let onStopHandlers: Array<() => void> = []\n\n  /**\n   * Stop watching the query\n   */\n  function stop () {\n    tryFirstResolve()\n    if (!started) return\n    started = false\n    loading.value = false\n\n    onStopHandlers.forEach(handler => handler())\n    onStopHandlers = []\n\n    if (query.value) {\n      query.value.stopPolling()\n      query.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = undefined\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  let isRestartDebounceSetup = false\n  function updateRestartFn () {\n    // On server, will be called before currentOptions is initialized\n    // @TODO investigate\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart\n    } else {\n      if (currentOptions.value?.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n      } else if (currentOptions.value?.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n      } else {\n        debouncedRestart = baseRestart\n      }\n      isRestartDebounceSetup = true\n    }\n  }\n\n  function restart () {\n    if (!started || restarting) return\n    if (!isRestartDebounceSetup) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying document\n  let currentDocument: DocumentNode | null | undefined = documentRef.value\n\n  // Enabled state\n\n  const forceDisabled = ref(lazy)\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  const isEnabled = computed(() => enabledOption.value && !forceDisabled.value && !!documentRef.value)\n\n  // Applying options first (in case it disables the query)\n  watch(() => unref(optionsRef), applyOptions, {\n    deep: true,\n    immediate: true,\n  })\n\n  function applyOptions (value: UseQueryOptions<TResult, TVariables>) {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }\n\n  // Applying document\n  watch(documentRef, applyDocument)\n\n  function applyDocument (value: DocumentNode | null | undefined) {\n    currentDocument = value\n    restart()\n  }\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(() => {\n    if (isEnabled.value) {\n      return variablesRef.value\n    } else {\n      return undefined\n    }\n  }, applyVariables, {\n    deep: true,\n    immediate: true,\n  })\n\n  function applyVariables (value?: TVariables) {\n    const serialized = JSON.stringify([value, isEnabled.value])\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }\n\n  // Refetch\n\n  function refetch (variables: TVariables | undefined = undefined) {\n    if (query.value) {\n      if (variables) {\n        currentVariables = variables\n      }\n      error.value = null\n      loading.value = true\n      return query.value.refetch(variables)\n        .then((refetchResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return refetchResult\n        })\n    }\n  }\n\n  // Update Query\n\n  function updateQuery (mapFn: (previousQueryResult: TResult, options: Pick<WatchQueryOptions<TVariables, TResult>, 'variables'>) => TResult) {\n    if (query.value) {\n      query.value.updateQuery(mapFn)\n    }\n  }\n\n  // Fetch more\n\n  function fetchMore (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) {\n    if (query.value) {\n      error.value = null\n      loading.value = true\n      return query.value.fetchMore(options)\n        .then((fetchMoreResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return fetchMoreResult\n        })\n    }\n  }\n\n  // Subscribe to more\n\n  const subscribeToMoreItems: SubscribeToMoreItem[] = []\n\n  function subscribeToMore<\n    TSubscriptionVariables = OperationVariables,\n    TSubscriptionData = TResult\n  > (\n    options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> |\n    Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> |\n    ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>,\n  ) {\n    if (isServer) return\n    const optionsRef = paramToRef(options)\n    watch(optionsRef, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item => item.options === oldValue)\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1)\n      }\n      const item: SubscribeToMoreItem = {\n        options: value,\n        unsubscribeFns: [],\n      }\n      subscribeToMoreItems.push(item)\n\n      addSubscribeToMore(item)\n\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn())\n        item.unsubscribeFns = []\n      })\n    }, {\n      immediate: true,\n    })\n  }\n\n  function addSubscribeToMore (item: SubscribeToMoreItem) {\n    if (!started) return\n    if (!query.value) {\n      throw new Error('Query is not defined')\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options)\n    onStopHandlers.push(unsubscribe)\n    item.unsubscribeFns.push(unsubscribe)\n  }\n\n  // Auto start & stop\n\n  watch(isEnabled, value => {\n    if (value) {\n      nextTick(() => {\n        start()\n      })\n    } else {\n      stop()\n    }\n  })\n\n  if (isEnabled.value) {\n    start()\n  }\n\n  // Teardown\n  if (currentScope) {\n    onScopeDispose(() => {\n      stop()\n      subscribeToMoreItems.length = 0\n    })\n  } else {\n    console.warn('[Vue apollo] useQuery() is called outside of an active effect scope and the query will not be automatically stopped.')\n  }\n\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    updateQuery,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { hasInjectionContext, inject } from 'vue-demi'\nimport { ApolloClient } from '@apollo/client/core/index.js'\n\nexport const DefaultApolloClient = Symbol('default-apollo-client')\nexport const ApolloClients = Symbol('apollo-clients')\n\ntype ClientId = string\ntype ClientDict<T> = Record<ClientId, ApolloClient<T>>\n\ntype ResolveClient<TCacheShape, TReturn = ApolloClient<TCacheShape>> = (clientId?: ClientId) => TReturn\ntype NullableApolloClient<TCacheShape> = ApolloClient<TCacheShape> | undefined\n\nexport interface UseApolloClientReturn<TCacheShape> {\n  resolveClient: ResolveClient<TCacheShape>\n  readonly client: ApolloClient<TCacheShape>\n}\n\nfunction resolveDefaultClient<T> (providedApolloClients: ClientDict<T> | null, providedApolloClient: ApolloClient<T> | null): NullableApolloClient<T> {\n  const resolvedClient = providedApolloClients\n    ? providedApolloClients.default\n    : (providedApolloClient ?? undefined)\n  return resolvedClient\n}\n\nfunction resolveClientWithId<T> (providedApolloClients: ClientDict<T> | null, clientId: ClientId): NullableApolloClient<T> {\n  return providedApolloClients?.[clientId]\n}\n\nexport function useApolloClient<TCacheShape = any> (clientId?: ClientId): UseApolloClientReturn<TCacheShape> {\n  let resolveImpl: ResolveClient<TCacheShape, NullableApolloClient<TCacheShape>>\n\n  // Save current client in current closure scope\n  const savedCurrentClients = currentApolloClients\n\n  if (!hasInjectionContext()) {\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  } else {\n    const providedApolloClients: ClientDict<TCacheShape> | null = inject(ApolloClients, null)\n    const providedApolloClient: ApolloClient<TCacheShape> | null = inject(DefaultApolloClient, null)\n\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        const client = resolveClientWithId(providedApolloClients, id)\n        if (client) {\n          return client\n        }\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient)\n      if (client) {\n        return client\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  }\n\n  function resolveClient (id: ClientId | undefined = clientId) {\n    const client = resolveImpl(id)\n    if (!client) {\n      throw new Error(\n        `Apollo client with id ${\n          id ?? 'default'\n        } not found. Use an app.runWithContext() or provideApolloClient() if you are outside of a component setup.`,\n      )\n    }\n    return client\n  }\n\n  return {\n    resolveClient,\n    get client () {\n      return resolveClient()\n    },\n  }\n}\n\nlet currentApolloClients: ClientDict<any> = {}\n\nexport function provideApolloClient<TCacheShape = any> (client: ApolloClient<TCacheShape>) {\n  currentApolloClients = {\n    default: client,\n  }\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n\nexport function provideApolloClients<TCacheShape = any> (clients: ClientDict<TCacheShape>) {\n  currentApolloClients = clients\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n","import { Ref, isRef, computed, ref } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\nexport function paramToRef<T> (param: T | Ref<T> | ReactiveFunction<T>): Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else {\n    return ref(param) as Ref<T>\n  }\n}\n","import { Ref, isRef, reactive, computed } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype TObject = object\n\nexport function paramToReactive<T extends TObject> (param: T | Ref<T> | ReactiveFunction<T>): T | Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else if (param) {\n    return reactive(param) as T\n  } else {\n    return param\n  }\n}\n","export function useEventHook<TParams extends any[] = any[]> () {\n  const fns: Array<(...params: TParams) => void> = []\n\n  function on (fn: (...params: TParams) => void) {\n    fns.push(fn)\n    return {\n      off: () => off(fn),\n    }\n  }\n\n  function off (fn: (...params: TParams) => void) {\n    const index = fns.indexOf(fn)\n    if (index !== -1) {\n      fns.splice(index, 1)\n    }\n  }\n\n  function trigger (...params: TParams) {\n    for (const fn of fns) {\n      fn(...params)\n    }\n  }\n\n  function getCount () {\n    return fns.length\n  }\n\n  return {\n    on,\n    off,\n    trigger,\n    getCount,\n  }\n}\n","import { Ref, watch, ref, getCurrentScope, onScopeDispose } from 'vue-demi'\nimport { isServer } from './env.js'\n\nimport type { EffectScope } from 'vue-demi'\n\nexport interface LoadingTracking {\n  queries: Ref<number>\n  mutations: Ref<number>\n  subscriptions: Ref<number>\n}\n\nexport interface AppLoadingTracking extends LoadingTracking {\n  components: Map<EffectScope, LoadingTracking>\n}\n\nexport const globalTracking: AppLoadingTracking = {\n  queries: ref(0),\n  mutations: ref(0),\n  subscriptions: ref(0),\n  components: new Map(),\n}\n\nexport function getCurrentTracking () {\n  const currentScope = getCurrentScope()\n  if (!currentScope) {\n    return {}\n  }\n\n  let tracking: LoadingTracking\n\n  if (!globalTracking.components.has(currentScope)) {\n    // Add per-component tracking\n    globalTracking.components.set(currentScope, tracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n    })\n    // Cleanup\n    onScopeDispose(() => {\n      globalTracking.components.delete(currentScope)\n    })\n  } else {\n    tracking = globalTracking.components.get(currentScope) as LoadingTracking\n  }\n\n  return {\n    tracking,\n  }\n}\n\nfunction track (loading: Ref<boolean>, type: keyof LoadingTracking) {\n  if (isServer) return\n\n  const { tracking } = getCurrentTracking()\n\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1\n      if (tracking) tracking[type].value += mod\n      globalTracking[type].value += mod\n    }\n  }, {\n    immediate: true,\n  })\n\n  onScopeDispose(() => {\n    if (loading.value) {\n      if (tracking) tracking[type].value--\n      globalTracking[type].value--\n    }\n  })\n}\n\nexport function trackQuery (loading: Ref<boolean>) {\n  track(loading, 'queries')\n}\n\nexport function trackMutation (loading: Ref<boolean>) {\n  track(loading, 'mutations')\n}\n\nexport function trackSubscription (loading: Ref<boolean>) {\n  track(loading, 'subscriptions')\n}\n","export const isServer = typeof window === 'undefined'\n","import { ApolloError, isApolloError } from '@apollo/client/core/index.js'\nimport { GraphQLErrors } from '@apollo/client/errors/index.js'\n\nexport function toApolloError (error: unknown): ApolloError {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), { originalError: error }),\n      errorMessage: String(error),\n    })\n  }\n\n  if (isApolloError(error)) {\n    return error\n  }\n\n  return new ApolloError({ networkError: error, errorMessage: error.message })\n}\n\nexport function resultErrorsToApolloError (errors: GraphQLErrors): ApolloError {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map((e: any) => e.message).join(' | ')}`,\n  })\n}\n","import { DocumentNode } from 'graphql'\nimport { isRef } from 'vue-demi'\nimport { useQueryImpl, DocumentParameter, VariablesParameter, OptionsParameter, UseQueryOptions, UseQueryReturn } from './useQuery'\nimport type { OperationVariables } from '@apollo/client/core'\nimport { isServer } from './util/env.js'\n\nexport interface UseLazyQueryReturn<TResult, TVariables extends OperationVariables> extends UseQueryReturn<TResult, TVariables> {\n  /**\n   * Activate the query and starts loading.\n   * @param document Override document\n   * @param variables Override variables\n   * @param options Override options\n   * @returns Returns false if the query is already active, otherwise the next result of the query.\n   */\n  load: (document?: DocumentNode | null, variables?: TVariables | null, options?: UseQueryOptions | null) => false | Promise<TResult>\n}\n\nexport function useLazyQuery<\n  TResult = any,\n  TVariables extends Record<string, unknown> = any,\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseLazyQueryReturn<TResult, TVariables> {\n  const query = useQueryImpl<TResult, TVariables>(document, variables, options, true)\n\n  function load (\n    document?: DocumentNode | null,\n    variables?: TVariables | null,\n    options?: UseQueryOptions | null,\n  ) {\n    if (document) {\n      query.document.value = document\n    }\n    if (variables) {\n      query.variables.value = variables\n    }\n    if (options) {\n      Object.assign(isRef(query.options) ? query.options.value : query.options, options)\n    }\n    const isFirstRun = query.forceDisabled.value\n    if (isFirstRun) {\n      query.forceDisabled.value = false\n\n      // If SSR, we need to start the query manually since `watch` on `isEnabled` in `useQueryImpl` won't be called.\n      if (isServer) {\n        query.start()\n      }\n\n      return new Promise<TResult>((resolve, reject) => {\n        const { off: offResult } = query.onResult((result) => {\n          if (!result.loading) {\n            resolve(result.data)\n            offResult()\n            offError()\n          }\n        })\n        const { off: offError } = query.onError((error) => {\n          reject(error)\n          offResult()\n          offError()\n        })\n      })\n    } else {\n      return false\n    }\n  }\n\n  return {\n    ...query,\n    load,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport { MutationOptions, OperationVariables, FetchResult, TypedDocumentNode, ApolloError, ApolloClient } from '@apollo/client/core/index.js'\nimport { ref, onScopeDispose, isRef, Ref, getCurrentScope, shallowRef, nextTick } from 'vue-demi'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { useEventHook } from './util/useEventHook'\nimport { trackMutation } from './util/loadingTracking'\nimport { toApolloError } from './util/toApolloError'\n\n/**\n * `useMutation` options for mutations that don't require `variables`.\n */\nexport interface UseMutationOptions<\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<MutationOptions<TResult, TVariables>, 'mutation'> {\n  clientId?: string\n  throws?: 'auto' | 'always' | 'never'\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype OptionsParameter<TResult, TVariables> = UseMutationOptions<TResult, TVariables> | Ref<UseMutationOptions<TResult, TVariables>> | ReactiveFunction<UseMutationOptions<TResult, TVariables>>\n\nexport type MutateOverrideOptions<TResult> = Pick<UseMutationOptions<TResult, OperationVariables>, 'update' | 'optimisticResponse' | 'context' | 'updateQueries' | 'refetchQueries' | 'awaitRefetchQueries' | 'errorPolicy' | 'fetchPolicy' | 'clientId'>\nexport type MutateResult<TResult> = Promise<FetchResult<TResult, Record<string, any>, Record<string, any>> | null>\nexport type MutateFunction<TResult, TVariables> = (variables?: TVariables | null, overrideOptions?: MutateOverrideOptions<TResult>) => MutateResult<TResult>\n\nexport interface OnDoneContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\nexport interface UseMutationReturn<TResult, TVariables> {\n  mutate: MutateFunction<TResult, TVariables>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  called: Ref<boolean>\n  onDone: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>, context: OnDoneContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\nexport function useMutation<\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseMutationReturn<TResult, TVariables> {\n  const currentScope = getCurrentScope()\n  const loading = ref<boolean>(false)\n  currentScope && trackMutation(loading)\n  const error = shallowRef<ApolloError | null>(null)\n  const called = ref<boolean>(false)\n\n  const doneEvent = useEventHook<[FetchResult<TResult, Record<string, any>, Record<string, any>>, OnDoneContext]>()\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  async function mutate (variables?: TVariables | null, overrideOptions: Omit<UseMutationOptions<TResult, TVariables>, 'variables'> = {}) {\n    let currentDocument: DocumentNode\n    if (typeof document === 'function') {\n      currentDocument = document()\n    } else if (isRef(document)) {\n      currentDocument = document.value\n    } else {\n      currentDocument = document\n    }\n\n    let currentOptions: UseMutationOptions<TResult, TVariables>\n    if (typeof options === 'function') {\n      currentOptions = options()\n    } else if (isRef(options)) {\n      currentOptions = options.value\n    } else {\n      currentOptions = options\n    }\n    const client = resolveClient(currentOptions.clientId)\n    error.value = null\n    loading.value = true\n    called.value = true\n    try {\n      const result = await client.mutate<TResult, TVariables>({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables ?? currentOptions.variables)\n          ? {\n            ...(currentOptions.variables as TVariables),\n            ...(variables as TVariables),\n          }\n          : undefined,\n      })\n      loading.value = false\n      await nextTick()\n      doneEvent.trigger(result, {\n        client,\n      })\n      return result\n    } catch (e) {\n      const apolloError = toApolloError(e)\n      error.value = apolloError\n      loading.value = false\n      errorEvent.trigger(apolloError, {\n        client,\n      })\n      if (currentOptions.throws === 'always' || (currentOptions.throws !== 'never' && !errorEvent.getCount())) {\n        throw apolloError\n      }\n    }\n    return null\n  }\n\n  currentScope && onScopeDispose(() => {\n    loading.value = false\n  })\n\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport {\n  Ref,\n  ref,\n  watch,\n  isRef,\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  nextTick,\n  shallowRef,\n} from 'vue-demi'\nimport type {\n  OperationVariables,\n  SubscriptionOptions,\n  FetchResult,\n  Observable,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n  ApolloClient,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useApolloClient } from './useApolloClient'\nimport { useEventHook } from './util/useEventHook'\nimport { trackSubscription } from './util/loadingTracking'\nimport { toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nexport interface UseSubscriptionOptions <\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<SubscriptionOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean | Ref<boolean>\n  throttle?: number\n  debounce?: number\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\ntype OptionsParameter<TResult, TVariables> = UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>> | ReactiveFunction<UseSubscriptionOptions<TResult, TVariables>>\n\nexport interface OnResultContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\nexport interface UseSubscriptionReturn<TResult, TVariables> {\n  result: Ref<TResult | null | undefined>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>>\n  subscription: Ref<Observable<FetchResult<TResult, Record<string, any>, Record<string, any>>> | null>\n  onResult: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>, context: OnResultContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a subscription that does not require variables or options.\n * */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseSubscriptionReturn<TResult, undefined>\n\n/**\n * Use a subscription that requires options but not variables.\n */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>\n): UseSubscriptionReturn<TResult, null>\n\n/**\n * Use a subscription that requires variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that has optional variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that requires variables and options.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\nexport function useSubscription <\n  TResult,\n  TVariables extends Record<string, unknown>\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables> | undefined = undefined,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseSubscriptionReturn<TResult, TVariables> {\n  const currentScope = getCurrentScope()\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  const result = shallowRef<TResult | null | undefined>()\n  const resultEvent = useEventHook<[FetchResult<TResult>, OnResultContext]>()\n  const error = shallowRef<ApolloError | null>(null)\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  const loading = ref(false)\n  currentScope && trackSubscription(loading)\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  const subscription: Ref<Observable<FetchResult<TResult>> | null> = ref(null)\n  let observer: ObservableSubscription | null = null\n  let started = false\n\n  function getClient () {\n    return resolveClient(currentOptions.value?.clientId)\n  }\n\n  function start () {\n    if (started || !isEnabled.value || isServer) return\n    started = true\n    loading.value = true\n\n    const client = getClient()\n\n    subscription.value = client.subscribe<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n    })\n\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (fetchResult: FetchResult<TResult>) {\n    result.value = fetchResult.data\n    loading.value = false\n    resultEvent.trigger(fetchResult, {\n      client: getClient(),\n    })\n  }\n\n  function onError (fetchError: unknown) {\n    const apolloError = toApolloError(fetchError)\n\n    error.value = apolloError\n    loading.value = false\n    errorEvent.trigger(apolloError, {\n      client: getClient(),\n    })\n  }\n\n  function stop () {\n    if (!started) return\n    started = false\n    loading.value = false\n\n    if (subscription.value) {\n      subscription.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = null\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  function updateRestartFn () {\n    if (currentOptions.value?.throttle) {\n      debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n    } else if (currentOptions.value?.debounce) {\n      debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n    } else {\n      debouncedRestart = baseRestart\n    }\n  }\n\n  function restart () {\n    if (!debouncedRestart) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying options\n  const currentOptions = ref<UseSubscriptionOptions<TResult, TVariables>>()\n  watch(() => isRef(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Internal enabled returned to user\n  // @TODO Doesn't fully work yet, need to initialize with option\n  // const enabled = ref<boolean>()\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  // const isEnabled = computed(() => !!((typeof enabled.value === 'boolean' && enabled.value) && enabledOption.value))\n  const isEnabled = enabledOption\n\n  // watch(enabled, value => {\n  //   if (value == null) {\n  //     enabled.value = enabledOption.value\n  //   }\n  // })\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  if (currentScope) {\n    onScopeDispose(stop)\n  } else {\n    console.warn('[Vue apollo] useSubscription() is called outside of an active effect scope and the subscription will not be automatically stopped.')\n  }\n\n  return {\n    result,\n    loading,\n    error,\n    // @TODO doesn't fully work yet\n    // enabled,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { Ref, computed } from 'vue-demi'\nimport { ExtractSingleKey } from './util/ExtractSingleKey'\nimport type { DeepNonNullable, DeepRequired } from 'ts-essentials'\n\nexport type UseResultReturn<T> = Readonly<Ref<Readonly<T>>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `undefined` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const user = useResult(result)\n * // user is `undefined` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @returns Readonly ref with `undefined` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>\n): UseResultReturn<undefined | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const profile = useResult(result, {})\n * // profile is `{}` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @returns Readonly ref with the `defaultValue` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TDefaultValue, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue\n): UseResultReturn<TDefaultValue | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning the `result` mapped with the `pick` function.\n * The `value` of the ref will be `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const comments = useResult(result, undefined, (data) => data.comments)\n * // user is `undefined`, then resolves to the result's `comments`\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @param  {(data:TResult)=>TReturnValue} pick The function that receives `result` and maps a return value from it.\n * @returns Readonly ref with the `defaultValue` or the resolved and `pick`-mapped `result`\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue | undefined,\n  pick: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue\n): UseResultReturn<TDefaultValue | TReturnValue>\n\n/**\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue?: TDefaultValue,\n  pick?: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue,\n): UseResultReturn<TResult | TResult[keyof TResult] | TDefaultValue | TReturnValue | undefined> {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`)\n  return computed(() => {\n    const value = result.value\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value as DeepRequired<DeepNonNullable<TResult>>)\n        } catch (e) {\n          // Silent error\n        }\n      } else {\n        const keys = Object.keys(value)\n        if (keys.length === 1) {\n          // Automatically take the only key in result data\n          return value[keys[0] as keyof TResult]\n        } else {\n          // Return entire result data\n          return value\n        }\n      }\n    }\n    return defaultValue\n  })\n}\n","import { getCurrentTracking, globalTracking } from './util/loadingTracking'\nimport { computed } from 'vue-demi'\n\nexport function useQueryLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useQueryLoading must be called inside a setup function.')\n  return computed(() => tracking.queries.value > 0)\n}\n\nexport function useMutationLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useMutationLoading must be called inside a setup function.')\n  return computed(() => tracking.mutations.value > 0)\n}\n\nexport function useSubscriptionLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useSubscriptionLoading must be called inside a setup function.')\n  return computed(() => tracking.subscriptions.value > 0)\n}\n\nexport function useGlobalQueryLoading () {\n  return computed(() => globalTracking.queries.value > 0)\n}\n\nexport function useGlobalMutationLoading () {\n  return computed(() => globalTracking.mutations.value > 0)\n}\n\nexport function useGlobalSubscriptionLoading () {\n  return computed(() => globalTracking.subscriptions.value > 0)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}